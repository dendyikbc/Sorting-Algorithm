# 排序算法总结
```
稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
内排序：所有排序操作都在内存中完成；
外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
时间复杂度： 一个算法执行所耗费的时间。
空间复杂度：运行完一个程序所需内存的大小。
```



排序的分类

- 比较排序
    - 快速排序
    - 归并排序
    - 堆排序
    - 冒泡排序
在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。  
在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。
比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。
- 非比较排序
    - 计数排序
    - 基数排序
    - 桶排序
非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。    

非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。
非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。

## 冒泡排序
最佳情况：T(n) = O(n) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2)

算法描述
- 1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 3.针对所有的元素重复以上的步骤，除了最后一个；
- 4.重复步骤1~3，直到排序完成。

`说明：按从小到大顺序排序，第一次遍历就将最大的数字放到了最后；进行第二次遍历时，只需比较到倒数第二个数字即可。`
```java
public static void bubbleSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        int length = array.length;//先写成临时变量

        // 外层循环控制比较轮数i，肯定是n次遍历比较
        for (int i = 0; i < length; i++) {
            // 内层循环控制每一轮比较次数，每进行一轮排序都会找出一个较大值，丢到最后
            // (array.length - 1)防止索引越界，(array.length - 1 - i)减少比较次数
            for (int j = 0; j < length - 1 - i; j++) {
                // 前面的数大于后面的数就进行交换
                if (array[j] > array[j + 1]) {
                    int temp = array[j + 1];
                    array[j + 1] = array[j];
                    array[j] = temp;
                }
            }
        }

    }
```

## 选择排序
最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2)

算法描述
n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

- 初始状态：无序区为R[1…n]，有序区为空；
- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
- n-1趟结束，数组有序化了。


表现最稳定的排序算法之一，无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。
唯一的好处可能就是不占用额外的内存空间了吧。

`说明：从小到大排序，有序区在前面，无序区在后面；初始化无序区第一个为最小，每一次在后面中寻找是否存在一个最小数字与无序区第一个元素交换`
```java

public static void selectionSort(int[] array) {
	if (array == null || array.length <= 1) {
		return;
	}

	int length = array.length;

	for (int i = 0; i < length - 1; i++) {//有序区在前面，i++这是在逐步缩小无序区长度
		// 保存最小数的索引
		int minIndex = i;//无序区第一个数字为最小索引初始化

		for (int j = i + 1; j < length; j++) {
			// 找到最小的数
			if (array[j] < array[minIndex]) {
				minIndex = j;
			}
		}

		// 交换元素位置,不等于才交换避免了两元素相等时的交换
		if (i != minIndex) {
			swap(array, minIndex, i);
		}
	}

}

private static void swap(int[] array, int a, int b) {
	int temp = array[a];
	array[a] = array[b];
	array[b] = temp;
}

```
## 插入排序
最佳情况：T(n) = O(n) 最坏情况：T(n) = O(n2) 平均情况：T(n) = O(n2)

算法描述
一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

- 1.从第一个元素开始，该元素可以认为已经被排序；
- 2.取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 3.如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 5.将新元素插入到该位置后；
- 6.重复步骤2~5。

说明：`默认索引0有序，然后无序区从索引1开始。针对无序区，无序区的每一个元素依次赋值临时变量insertnum，依次倒叙的与有序区最后一元素开始相比，期间有序区元素后移，insertnum寻找合适位置插入。`
```java

public static void insertionSort(int[] array) {
	if (array == null || array.length <= 1) {
		return;
	}

	int length = array.length;

	// 要插入的数
	int insertNum;

	for (int i = 1; i < length; i++) {
		insertNum = array[i];//索引0默认可认为有序，所以从索引1开始
		// 已经排序好的元素个数
		int j = i - 1;
		while (j >= 0 && array[j] > insertNum) {
			// 针对前面有序区，从后到前循环，将大于insertNum的数向后移动一格
			array[j + 1] = array[j];
			j--;//索引前移，准备与前一个数比较
		}

		// 跳出while，索引j位置元素比insertnum小，所以在索引j+1处插入
        //将需要插入的数放在要插入的位置
		array[j + 1] = insertNum;
	}
}

```



